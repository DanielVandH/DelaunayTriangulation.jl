using SimpleGraphs
using ExactPredicates
using ExactPredicates.Codegen
using Test
using Random
const TriangleType = NTuple{3,Int64}
const LargeRightIdx = 0 # p‚Çã‚ÇÅ
const LargeLeftIdx = -1 # p‚Çã‚ÇÇ
const EmptyIdx = -2 # ‚àÖ
const VertexNeighbourVector = Vector{Int64}
const AdjacentToVertexVector = Vector{NTuple{2, Int64}}
"""
    TriangulationDAG <: AbstractSimpleGraph

Data structure for the Delaunay triangulation. This is a directed acyclic graph 
that is useful for point location.
"""
struct TriangulationDAG <: AbstractSimpleGraph
    graph::DirectedGraph{TriangleType}
    function TriangulationDAG()
        G = DirectedGraph{TriangleType}()
        forbid_loops!(G)
        TDAG = new(G)
        return TDAG
    end
end
const TriDAG = TriangulationDAG
graph(G::TriangulationDAG) = G.graph
for op in (:out_deg, :in_deg, :deg,
    :dual_deg, :in_neighbors,
    :NE, :has, :delete!,
    :elist)
    @eval begin
        SimpleGraphs.$op(G::TriDAG) = SimpleGraphs.$op(graph(G))
        SimpleGraphs.$op(G::TriDAG, u) = SimpleGraphs.$op(graph(G), u)
        SimpleGraphs.$op(G::TriDAG, u, v) = SimpleGraphs.$op(graph(G), u, v)
    end
end
SimpleGraphs.out_neighbors(G::TriDAG, u) = graph(G).N[u] # The version in SimpleGraphs is allocating...
SimpleGraphs.add!(G::TriDAG, u) = SimpleGraphs.add!(graph(G), u)
"""
    SimpleGraphs.add!(G::TriDAG, u)

Add the triangle `u` to the graph `G`. Checks that cyclic permutations of `u`'s indices are not 
in `G` already, returning `false` otherwise.
"""
function SimpleGraphs.add!(G::TriDAG, u)
    for i = 1:3
        i‚ÇÅ, i‚ÇÇ, i‚ÇÉ = i, (i % 3) + 1, ((i + 1) % 3) + 1
        has(G, TriangleType((u[i‚ÇÅ], u[i‚ÇÇ], u[i‚ÇÉ]))) && return false
    end
    return SimpleGraphs.add!(graph(G), u)
end
"""
    SimpleGraphs.add!(G::TriDAG, u, v)

Adds an edge between triangle `u ‚àà G` and `v ‚àà G` to the graph `G`. Checks 
are made for cyclic permutations of `u` and `v`'s indices.
"""
function SimpleGraphs.add!(G::TriDAG, u, v)
    for i in 1:3
        for j in 1:3
            i‚ÇÅ, i‚ÇÇ, i‚ÇÉ = i, (i % 3) + 1, ((i + 1) % 3) + 1
            j‚ÇÅ, j‚ÇÇ, j‚ÇÉ = j, (j % 3) + 1, ((j + 1) % 3) + 1
            T = TriangleType((u[i‚ÇÅ], u[i‚ÇÇ], u[i‚ÇÉ]))
            V = TriangleType((v[j‚ÇÅ], v[j‚ÇÇ], v[j‚ÇÉ]))
            if has(G, T) && has(G, V)
                SimpleGraphs.add!(graph(G), T, V)
                return true
            end
        end
    end
    return false
end

"""
    find_root(G::TriDAG; method=:brute)

Finds the root of the graph `G`, assuming only one root exists and the only node with in-degree zero is this root. 
There are two methods:

    - `method=:brute`: In this case, all vertices are searched until one is found with in-degree zero.
    - `method=:rng`: In this case, a random integer is selected, defniing the node to start at. 
    We then go upwards until the root is found; note that this only works as the graph is acyclic.
"""
function find_root(G::TriDAG; method=:brute)
    if method == :brute
        return _find_root_brute(G)
    elseif method == :rng
        return _find_root_rng(G)
    end
end
function _find_root_brute(G::TriDAG)
    for (k, v) in graph(G).NN
        length(v) == 0 && return k
    end
end
function _find_root_rng(G::TriDAG)
    verts = vlist(graph(G))
    num_verts = length(verts)
    starting_node = verts[rand(1:num_verts)]
    for _ in 1:num_verts
        num_choices = in_deg(G, starting_node)
        num_choices == 0 && return starting_node
        starting_node = in_neighbors(G, starting_node)[rand(1:num_choices)]
    end
end

"""
    TriangulationAdjacent{A}

This is a data structure for the Delaunay triangulation. It stores a `Dict`, `adjacent`, so that 
`(u, v, adjacent[(u, v)])` is a positively oriented triangle. This struct is also callable, e.g. if 
`ùíú::TriangulationAdjacent`, then `(u, v, ùíú(u, v))` is a positively oriented triangle.
"""
struct TriangulationAdjacent{A}
    adjacent::A
    function TriangulationAdjacent()
        D = Dict{NTuple{2,Int64},Int64}()
        TADJ = new{typeof(D)}(D) # TADJ = (T)riangulation(ADJ)acent
        return TADJ
    end
end
const TriAdjacent = TriangulationAdjacent
Base.setindex!(adj::TriAdjacent, w, uv) = Base.setindex!(adj.adjacent, w, uv) # (u, v, w) is a positively oriented triangle
Base.getindex(adj::TriAdjacent, uv) = Base.getindex(adj.adjacent, uv) # Find the w so that (u, v, w) is a positively oriented triangle
edges(adj::TriAdjacent) = keys(adj.adjacent) # List of edges - note that there are duplicates, i.e. (u, v) and (v, u) are both stored.
(adj::TriAdjacent)(u, v) = adj[(u, v)] # Find the w so that (u, v, w) is a positively oriented triangle

""" 
    TriangulationAdjacentToVertex{A‚Åª¬π}

This is a data structure for the Delaunay triangulation. It stores a `Dict`, `adjacent2vertex`, so that, 
for each `(u, v) ‚àà adjacent2vertex[w]`, `(u, v, w)` is a positively oriented triangle. Note that 
this is the inverse of `TriangulationAdjacent`.
"""
struct TriangulationAdjacentToVertex{A‚Åª¬π}
    adjacent2vertex::A‚Åª¬π
    function TriangulationAdjacentToVertex()
        D = Dict{Int64, AdjacentToVertexVector}()
        TA2V = new{typeof(D)}(D)
        return TA2V 
    end 
end
const TriAdjacent2Vertex = TriangulationAdjacentToVertex
Base.setindex!(adj::TriAdjacent2Vertex, uv, w) = Base.setindex!(adj.adjacent2vertex, uv, w) # (u, v, w) is a positively oriented triangle
Base.getindex(adj::TriAdjacent2Vertex, w) = Base.getindex(adj.adjacent2vertex, w) # Find the (u, v) so that (u, v, w) is a positively oriented triangle

"""
    TriangulationVertexNeighbours{N}

This is a data structure for the Delaunay triangulation. It stores a `Dict`, `neighbours`, so 
that `neighbours[u]` is a list of points that share an edge with the point `u`.
"""
struct TriangulationVertexNeighbours{N}
    neighbours::N
    function TriangulationVertexNeighbours()
        D = Dict{Int64,VertexNeighbourVector}()
        TVN = new{typeof(D)}(D) # TVN = (T)riangulation(V)ertex(N)eighbours 
        return TVN
    end
    TriangulationVertexNeighbours(tvn::N) where {N} = new{N}(tvn)
end
const TriVertexNeighbours = TriangulationVertexNeighbours
Base.setindex!(tvn::TriVertexNeighbours, v::AbstractVector, u) = Base.setindex!(tvn.neighbours, v, u) # This will add v to the list of neighbours in tvn.neighbours[u]
Base.setindex!(tvn::TriVertexNeighbours, v::Integer, u) = Base.setindex!(tvn, [v], u)
Base.getindex(tvn::TriVertexNeighbours, u) = Base.getindex(tvn.neighbours, u) # Find the neighbours of u 
Base.push!(tvn::TriVertexNeighbours, u, v::AbstractVector) = Base.push!(tvn.neighbours[u], v...) # Push v onto the list of neighbours of u 
Base.push!(tvn::TriVertexNeighbours, u, v::Integer) = Base.push!(tvn.neighbours[u], v) # Push v onto the list of neighbours of u 
(tvn::TriVertexNeighbours)(u) = tvn.neighbours[u] # Call tvn to get the neighbours of u
points(tvn::TriVertexNeighbours) = keys(tvn.neighbours)
"""
add_neighbour!(tvn::TriVertexNeighbours, u::Integer, v...; new_point=u ‚àâ points(tvn))

Adds the point `v` to `tvn.neighbours[u]`, or introduces the key `u` and adds the point. Declare if this 
point is new or not (i.e. an existing key of `tvn.neighbours`) using the keyword `new_point`.
"""
function add_neighbour!(tvn::TriVertexNeighbours, u::Integer, v; new_point=u ‚àâ points(tvn))
    if !new_point
        push!(tvn, u, v)
        return nothing
    else
        tvn[u] = v
        return nothing
    end
end
function add_neighbour!(tvn::TriVertexNeighbours, u::Integer, v::Integer...; new_point=u ‚àâ points(tvn))
    if !new_point
        push!(tvn, u, v...)
        return nothing
    else
        tvn[u] = [v...]
    end
end

function ExactPredicates.orient(ùíØ::TriangleType, pts)
    u, v, w = ùíØ
    return orient(pts[u], pts[v], pts[w])
end
function ExactPredicates.incircle(pts, i, j, k, ‚Ñì)
    return incircle(pts[i], pts[j], pts[k], pts[‚Ñì])
end

"""
    leftofline(x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ)

Tests if the point (x‚ÇÅ, x‚ÇÇ) is to the left of the half-plane formed 
from the oriented line through (x‚ÇÇ, y‚ÇÇ) to (x‚ÇÉ, y‚ÇÉ).

This is the same as `orient((x‚ÇÇ, y‚ÇÇ), (x‚ÇÅ, y‚ÇÅ), (x‚ÇÉ, y‚ÇÉ))`.
"""
@genpredicate function leftofline(x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ)
    Codegen.group!(x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ)
    return x‚ÇÅ * y‚ÇÇ - x‚ÇÇ * y‚ÇÅ - x‚ÇÅ * y‚ÇÉ + x‚ÇÉ * y‚ÇÅ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ
end
"""
    leftofline(pts, p, i, j)

Tests if the point `p` is to the left of the oriented line through 
`pts[i]` to `pts[j]`. Checks are made for non-positive indices.
"""
function leftofline(pts, p, i, j)
    if j == LargeRightIdx && i > LargeRightIdx      # p‚Çã‚ÇÅ ‚Üí p·µ¢
        return p > pts[i] ? 1 : -1
    elseif j == LargeLeftIdx && i > LargeRightIdx   # p‚Çã‚ÇÇ ‚Üí p·µ¢
        return p < pts[i] ? 1 : -1
    elseif i == LargeRightIdx && j > LargeRightIdx  # p‚Çã‚ÇÅ ‚Üí p·µ¢
        return p < pts[j] ? 1 : -1
    elseif i == LargeLeftIdx && j > LargeRightIdx   # p‚Çã‚ÇÇ ‚Üí p·µ¢
        return p > pts[j] ? 1 : -1
    elseif i == LargeRightIdx && j == LargeLeftIdx  # p‚Çã‚ÇÅ ‚Üí p‚Çã‚ÇÇ
        return -1
    elseif i == LargeLeftIdx && j == LargeRightIdx  # p‚Çã‚ÇÇ ‚Üí p‚Çã‚ÇÅ
        return 1
    end
    x, y = p
    x‚ÇÇ, y‚ÇÇ = pts[i]
    x‚ÇÉ, y‚ÇÉ = pts[j]
    return leftofline(x, y, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ)
end

function intriangle(e1, e2, e3) # https://stackoverflow.com/a/2049593
    if e1 == 0 || e2 == 0 || e3 == 0
        return 0
    end
    has_neg = e1 < 0 || e2 < 0 || e3 < 0
    has_pos = e1 > 0 || e2 > 0 || e3 > 0
    if has_neg && has_pos
        return -1
    else
        return 1
    end
end
function intriangle(ùíØ::TriangleType, pts, p)
    i, j, k = ùíØ
    e1 = leftofline(pts, p, i, j)
    e2 = leftofline(pts, p, j, k)
    e3 = leftofline(pts, p, k, i)
    return intriangle(e1, e2, e3)
end
function intriangle(x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ, x, y)
    e1 = leftofline(x, y, x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ)
    e2 = leftofline(x, y, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ)
    e3 = leftofline(x, y, x‚ÇÉ, y‚ÇÉ, x‚ÇÅ, y‚ÇÅ)
    return intriangle(e1, e2, e3)
end
function intriangle(p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p)
    x, y = p
    x‚ÇÅ, y‚ÇÅ = p‚ÇÅ
    x‚ÇÇ, y‚ÇÇ = p‚ÇÇ
    x‚ÇÉ, y‚ÇÉ = p‚ÇÉ
    return intriangle(x‚ÇÅ, y‚ÇÅ, x‚ÇÇ, y‚ÇÇ, x‚ÇÉ, y‚ÇÉ, x, y)
end

"""
    locate_triangle(ùíü::TriDAG, pts, p, init=find_root(ùíü; method=:rng))

Given the point location data structure `D` and a set of `pts`, finds the triangle in 
the current triangulation such that `p` is in its interior. The point location starts at `init`.
The function is recursive, and returns a tuple `(tri, flag)`:
    - `tri`: This is the triangle that `p` is in.
    - `flag`: If `flag == 0`, then `p` is on an edge of `tri`. Otherwise, it is in the open interior.
"""
function locate_triangle(ùíü::TriDAG, pts, p, init=find_root(ùíü; method=:rng))
    # Find which triangle in ùíü, containing points from the point set pts, 
    #   contains the point p, starting from the node root.
    if out_deg(ùíü, init) == 0
        return init, intriangle(init, pts, p)
    end
    out = out_neighbors(ùíü, init)
    for T in out
        intriangle(T, pts, p) ‚â• 0 && return locate_triangle(ùíü, pts, p, T)
    end
end

"""
    add_edge!(ùíú::TriAdjacent, u, v, w)

This adds the edge `(u, v)` to the adjacency list `ùíú`, mapping 
`(u, v)` to `w` so that `(u, v, w)` is a positively oriented triangle.
"""
function add_edge!(ùíú::TriAdjacent, u, v, w)
    ùíú[(u, v)] = w
    return nothing
end

"""
    add_edge!(ùíú‚Åª¬π::TriAdjacent2Vertex, w, u, v)

This adds the edge `(u, v)` to `ùíú‚Åª¬π[w]`.
"""
function add_edge!(ùíú‚Åª¬π::TriAdjacent2Vertex, w, u, v)
    uv = get!(AdjacentToVertexVector, ùíú‚Åª¬π, w) # https://discourse.julialang.org/t/how-do-i-append-add-data-in-dictionary-with-same-key/15891/5?u=legola18
    push!(uv, (u, v))
    return nothing
end

"""
    update_adjacent!(ùíú::TriAdjacent, ùíú‚Åª¬π::TriAdjacent2Vertex,, ùíØ::TriangleType...)

Updates the adjacency list `ùíú`, and its inverse `ùíú‚Åª¬π`, with the edges from `ùíØ`, keying on each edge. 
`ùíØ` must be positively oriented.
"""
function update_adjacent!(ùíú::TriAdjacent, ùíú‚Åª¬π::TriAdjacent2Vertex, ùíØ::TriangleType...)
    for T in ùíØ
        i, j, k = T
        add_edge!(ùíú, i, j, k)
        add_edge!(ùíú, j, k, i)
        add_edge!(ùíú, k, i, j)
        add_edge!(ùíú‚Åª¬π, k, i, j)
        add_edge!(ùíú‚Åª¬π, i, j, k)
        add_edge!(ùíú‚Åª¬π, j, k, i)
    end
    return nothing
end

"""
    delete_triangle!(ùíØ, T...)

Deletes the triangle(s) `T` from `ùíØ`, and all circular shifts of their indices.
"""
function delete_triangle!(ùíØ, T...)
    for T in T
        deleteat!(ùíØ, findall(x -> x == T || x == T[[2, 3, 1]] || x == T[[3, 1, 2]], ùíØ))
    end
    return nothing
end

"""
    add_triangle!(ùíØ, T...)

Adds the triangle(s) `T` to `ùíØ`.
"""
function add_triangle!(ùíØ, T...)
    push!(ùíØ, T...)
    return nothing
end
function add_triangle!(ùíü::TriDAG, ùíØ...)
    for T in ùíØ
        add!(ùíü, T)
    end
    return nothing
end

function add_edge!(ùíü::TriDAG, ùíØ, ùíØnew...)
    for T in ùíØnew
        add!(ùíü, ùíØ, T)
    end
    return nothing
end

"""
    delete_edge_from_adjacency!(ùíú, i, j; protect_boundary = true)

Deletes the keys `(i, j)` and `(j, i)` from `ùíú`. Use `protect_boundary=true` to avoid 
removing edges on the boundary.
"""
function delete_edge_from_adjacency!(ùíú, i, j; protect_boundary=true)
    if protect_boundary
        ùíú(i, j) ‚â† EmptyIdx && delete!(ùíú.adjacent, (i, j))
        ùíú(j, i) ‚â† EmptyIdx && delete!(ùíú.adjacent, (j, i))
    else
        delete!(ùíú.adjacent, (i, j))
        delete!(ùíú.adjacent, (j, i))
    end
    w·µ¢‚±º = ùíú(i, j)
    w‚±º·µ¢ = ùíú(j, i)
    return nothing
end

"""
    delete_point_from_neighbour!(ùí±ùí©, u, v)

Removes the point `v` from the neighbourhood of `u`, updating `ùí±ùí©` in-place.
"""
function delete_point_from_neighbour!(ùí±ùí©::TriVertexNeighbours, u, v)
    idx = findfirst(x -> x == v, ùí±ùí©(u))
    deleteat!(ùí±ùí©[u], idx)
    return nothing
end

"""
    add_point!(ùíØ, ùíü, ùíú, ùíú‚Åª¬π, T·µ¢‚±º‚Çñ, r)

Given a triangulation `ùíØ`, adds the `r`th point of the point set into the triangulation.

# Arguments 
- `ùíØ`: The current triangulation.
- `ùíü`: The point location data structure.
- `ùíú`: The adjacency list.
- `ùíú‚Åª¬π`: The adjacent-to-vertex list.
- `ùí±ùí©`: The vertex-neighbour data structure.
-` T·µ¢‚±º‚Çñ`: The triangle that the `r`th point is inside of. Must be positively oriented.
- `r`: The index of the point in the original point set that is being introduced.

# Outputs 
`ùíØ`, `ùíü`, and `ùíú` are all updated in-place.
"""
function add_point!(ùíØ, ùíü, ùíú, ùíú‚Åª¬π, ùí±ùí©, T·µ¢‚±º‚Çñ, r)
    i, j, k = T·µ¢‚±º‚Çñ # The triangle to be split into three
    delete_triangle!(ùíØ, T·µ¢‚±º‚Çñ) # Now that we've split the triangle, we can remove the triangle
    T‚ÇÅ, T‚ÇÇ, T‚ÇÉ = TriangleType((i, j, r)), TriangleType((j, k, r)), TriangleType((k, i, r)) # New triangles to add. Note that these triangles are all positively oriented.
    add_triangle!(ùíØ, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ) # The three new triangles
    add_triangle!(ùíü, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ) # Add the new triangles into DAG
    add_edge!(ùíü, T·µ¢‚±º‚Çñ, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ) # Add edges from the old triangle to the new triangles
    update_adjacent!(ùíú,ùíú‚Åª¬π, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ) # Add the new edges into the adjacency list
    add_neighbour!(ùí±ùí©, r, i, j, k; new_point=true)
    add_neighbour!(ùí±ùí©, i, r; new_point=false)
    add_neighbour!(ùí±ùí©, j, r; new_point=false)
    add_neighbour!(ùí±ùí©, k, r; new_point=false)
    return nothing
end

"""
    edge_on_large_triangle(i, j)

Returns true if `(i, j)` is an edge of the triangle `(1, -1, 0)`.
"""
function edge_on_large_triangle(i, j)
    if i > (LargeRightIdx + 1) || j > (LargeRightIdx + 1) # = 1 case can be p‚ÇÄ 
        return false
    elseif (i, j) == (LargeRightIdx + 1, LargeRightIdx) ||
           (i, j) == (LargeRightIdx, LargeLeftIdx) ||
           (i, j) == (LargeLeftIdx, LargeRightIdx + 1) ||
           (i, j) == (LargeRightIdx, LargeRightIdx + 1) ||
           (i, j) == (LargeLeftIdx, LargeRightIdx) ||
           (i, j) == (LargeRightIdx + 1, LargeLeftIdx)
        return true
    else
        return false
    end
end

"""
    is_legal(i, j, ùíú, pts)

Tests if the edge `(i, j)` is a legal edge. `ùíú` is the adjacency list of the triangulation, and `pts` is the point set.
Returns `true` if the edge is legal.
"""
function is_legal(i, j, k, ‚Ñì, pts)
    if i > LargeRightIdx && j > LargeRightIdx && k > LargeRightIdx && ‚Ñì > LargeRightIdx
        return incircle(pts, i, j, k, ‚Ñì) ‚â§ 0
    else
        return min(k, ‚Ñì) < min(i, j)
    end
end
function is_legal(i, j, ùíú, pts)
    edge_on_large_triangle(i, j) && return true
    k, ‚Ñì = ùíú(i, j), ùíú(j, i)
    return is_legal(i, j, k, ‚Ñì, pts)
end

"""
    flip_edge!(ùíØ, ùíü, ùíú, ùíú‚Åª¬π, i, j, k, r)

Performs an edge flip, flipping the edge `(i, j)` into the edge `(k, r)`.

# Arguments
- `ùíØ`: The current triangulation.
- `ùíü`: The point location data structure.
- `ùíú`: The adjacency list.
- `ùíú‚Åª¬π`: The adjacent-to-vertex list.
- `ùí±ùí©`: The vertex-neighbour data structure.
- `i, j`: The current edge.
- `k, r`: Indices for the points the edge is flipped onto.

It is assumed that `(i, k, j)` and `(i, j, r)` are positively oriented triangles.

# Outputs 
`ùíØ`, `ùíü`, and `ùíú` are all updated in-place.
"""
function flip_edge!(ùíØ, ùíü, ùíú, ùíú‚Åª¬π, ùí±ùí©, i, j, k, r)
    # The old triangles
    T·µ¢‚Çñ‚±º = TriangleType((i, k, j))
    T·µ¢‚±º·µ£ = TriangleType((i, j, r))
    delete_triangle!(ùíØ, T·µ¢‚Çñ‚±º, T·µ¢‚±º·µ£)
    delete_edge_from_adjacency!(ùíú, i, j)
    delete_point_from_neighbour!(ùí±ùí©, i, j)
    delete_point_from_neighbour!(ùí±ùí©, j, i)
    # The new triangles 
    T·µ£‚Çñ‚±º = TriangleType((r, k, j))
    T·µ£·µ¢‚Çñ = TriangleType((r, i, k))
    # Add the new triangles to the data structure
    add_triangle!(ùíØ, T·µ£‚Çñ‚±º, T·µ£·µ¢‚Çñ)
    add_triangle!(ùíü, T·µ£‚Çñ‚±º, T·µ£·µ¢‚Çñ)
    update_adjacent!(ùíú, T·µ£‚Çñ‚±º)
    update_adjacent!(ùíú, T·µ£·µ¢‚Çñ)
    # Connect the new triangles to the replaced triangles in the DAG
    add_edge!(ùíü, T·µ¢‚Çñ‚±º, T·µ£‚Çñ‚±º, T·µ£·µ¢‚Çñ)
    add_edge!(ùíü, T·µ¢‚±º·µ£, T·µ£‚Çñ‚±º, T·µ£·µ¢‚Çñ)
    # Add the new neighbours 
    add_neighbour!(ùí±ùí©, r, k; new_point=false)
    add_neighbour!(ùí±ùí©, k, r; new_point=false)
    return nothing
end

"""
    legalise_edge!(ùíØ, ùíü, ùíú, i, j, r, pts)
    
Legalises the edge `(i, j)` if it is illegal.

# Arguments 
- `ùíØ`: The current triangulation.
- `ùíü`: The point location data structure.
- `ùíú`: The adjacency list.
- `ùí±ùí©`: The vertex-neighbour data structure.
- `i, j`: The edge to make legal. Nothing happens if `is_legal(i, j, ùíú, pts)`.
- `r`: The point being added into the triangulation. 
- `pts`: The point set of the triangulation.

# Outputs 
`ùíØ`, `ùíü`, `ùíú`, and `ùí±ùí©` are all updated in-place.
"""
function legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, r, pts)
    if !is_legal(i, j, ùíú, pts)
        k = ùíú(j, i)
        flip_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, k, r)
        legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, k, r, pts)
        legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, k, j, r, pts)
    end
    return nothing
end

"""
    initialise_triangulation()

This function returns the initial data structures for the Delaunay triangulation:

- `ùíØ`: Data structure to contain the list of triangles.
- `ùíü`: The directed acyclic graph storing the history of the triangulation. 
- `ùíú`: The adjacency list.
- `ùí±ùí©`: A dictionary that maps points to their neighbours.
- `root`: The root of `ùíü`, `ùíØ[begin]`.
"""
function initialise_triangulation()
    # The data structures
    ùíØ = TriangleType[(LargeRightIdx + 1, LargeLeftIdx, LargeRightIdx)]
    ùíü = TriDAG()
    ùíú = TriAdjacent()
    ùí±ùí© = TriVertexNeighbours()
    # Add the root to the DAG
    add_triangle!(ùíü, ùíØ[begin])
    root = ùíØ[begin]
    # Add the initial adjacencies 
    ùíú[(LargeRightIdx + 1, LargeLeftIdx)] = LargeRightIdx
    ùíú[(LargeLeftIdx, LargeRightIdx)] = LargeRightIdx + 1
    ùíú[(LargeRightIdx, LargeRightIdx + 1)] = LargeLeftIdx
    ùíú[(LargeLeftIdx, LargeRightIdx + 1)] = EmptyIdx
    ùíú[(LargeRightIdx, LargeLeftIdx)] = EmptyIdx
    ùíú[(LargeRightIdx + 1, LargeRightIdx)] = EmptyIdx
    # Add the initial neighbours 
    add_neighbour!(ùí±ùí©, LargeRightIdx + 1, LargeLeftIdx, LargeRightIdx; new_point=true)
    add_neighbour!(ùí±ùí©, LargeLeftIdx, LargeRightIdx, LargeRightIdx + 1; new_point=true)
    add_neighbour!(ùí±ùí©, LargeRightIdx, LargeRightIdx + 1, LargeLeftIdx; new_point=true)
    return ùíØ, ùíü, ùíú, ùí±ùí©, root
end


function remove_bounding_triangle!()
    # First look at p‚Çã‚ÇÅ
    p‚Çã‚ÇÅ_neighbours = ùí±ùí©(-1)
    for i in p‚Çã‚ÇÅ_neighbours 
        delete_edge_from_adjacency!(ùíú, -1, i)
        delete_point_from_neighbour!(ùí±ùí©, -1, i)
end

# Test that we can correctly construct and index the vertex neighbour structure 
tvn = Dict(1 => [4, 5, 6, 9], 2 => [11, 9, 8, 15, 16], 3 => [1])
ùí±ùí© = TriVertexNeighbours(tvn)
ùí±ùí©2 = TriangulationVertexNeighbours(tvn)
@test ùí±ùí©2.neighbours == ùí±ùí©.neighbours
@test ùí±ùí©.neighbours == tvn
@test ùí±ùí©(1) == [4, 5, 6, 9]
@test ùí±ùí©(2) == [11, 9, 8, 15, 16]
@test ùí±ùí©(3) == [1]
@test ùí±ùí©[1] == [4, 5, 6, 9]
@test ùí±ùí©[2] == [11, 9, 8, 15, 16]
@test ùí±ùí©[3] == [1]
ùí±ùí©[4] = 5
@test ùí±ùí©[4] == [5]
ùí±ùí©[5] = [6]
@test ùí±ùí©[5] == [6]
ùí±ùí©[7] = [1, 2, 3, 4, 5, 6, 7]
@test ùí±ùí©[7] == [1, 2, 3, 4, 5, 6, 7]
push!(ùí±ùí©, 3, [1, 2, 3])
@test ùí±ùí©[3] == [1, 1, 2, 3]
push!(ùí±ùí©, 5, 1)
@test ùí±ùí©[5] == [6, 1]
push!(ùí±ùí©, 5, 3, 5, 1, 5)
@test ùí±ùí©[5] == [6, 1, 3, 5, 1, 5]
@test points(ùí±ùí©) == keys(ùí±ùí©.neighbours)
@test collect(points(ùí±ùí©)) == [5, 4, 7, 2, 3, 1]
add_neighbour!(ùí±ùí©, 1, 10)
@test ùí±ùí©(1) == [4, 5, 6, 9, 10]
add_neighbour!(ùí±ùí©, 1, 11, 12, 13)
@test ùí±ùí©(1) == [4, 5, 6, 9, 10, 11, 12, 13]
add_neighbour!(ùí±ùí©, 1, [14, 19])
@test ùí±ùí©(1) == [4, 5, 6, 9, 10, 11, 12, 13, 14, 19]
add_neighbour!(ùí±ùí©, 10, 14)
@test ùí±ùí©(10) == [14]
add_neighbour!(ùí±ùí©, 11, [15])
@test ùí±ùí©(11) == [15]
add_neighbour!(ùí±ùí©, 13, 15, 16, 19, 20)
@test ùí±ùí©(13) == [15, 16, 19, 20]
ùí±ùí©_empty = TriVertexNeighbours()
@test isempty(ùí±ùí©_empty.neighbours)
@test isempty(points(ùí±ùí©_empty))
add_neighbour!(ùí±ùí©_empty, 2, [2, 3, 4, 5, 1])
@test ùí±ùí©_empty[2] == [2, 3, 4, 5, 1]
@test_throws KeyError push!(ùí±ùí©_empty, 6, 10)
ùí±ùí©_empty[15] = 20
@test ùí±ùí©_empty(15) == ùí±ùí©_empty[15] == [20]
add_neighbour!(ùí±ùí©_empty, 15, 27; new_point=false)
@test ùí±ùí©_empty[15] == [20, 27]
@test_throws KeyError add_neighbour!(ùí±ùí©_empty, 20, 27; new_point=false)
add_neighbour!(ùí±ùí©_empty, 15, 273; new_point=false)
@test ùí±ùí©_empty[15] == [20, 27, 273]
@test_throws KeyError add_neighbour!(ùí±ùí©_empty, 20, 27, 53, 103; new_point=false)
add_neighbour!(ùí±ùí©_empty, 15, 273, 109, 81; new_point=false)
@test ùí±ùí©_empty[15] == [20, 27, 273, 273, 109, 81]
add_neighbour!(ùí±ùí©_empty, 29, 31)
@test ùí±ùí©_empty[29] == [31]
add_neighbour!(ùí±ùí©_empty, 37, 38, 39, 30, 1, 1, 2)
@test ùí±ùí©_empty[37] == [38, 39, 30, 1, 1, 2]

## Test that we can delete points from a neighbourhood 
tvn = Dict(1 => [4, 5, 6, 9], 2 => [11, 9, 8, 15, 16], 3 => [1])
ùí±ùí© = TriVertexNeighbours(tvn)
delete_point_from_neighbour!(ùí±ùí©, 1, 6)
@test ùí±ùí©[1] == [4, 5, 9]
@test ùí±ùí©[2] == [11, 9, 8, 15, 16]
@test ùí±ùí©[3] == [1]

# Test that we can correctly add and delete triangles 
ùíØ = TriangleType[(1, 2, 3), (3, 2, 5), (2, 1, 9)]
delete_triangle!(ùíØ, (1, 2, 3))
@test ùíØ == TriangleType[(3, 2, 5), (2, 1, 9)]
delete_triangle!(ùíØ, (5, 3, 2))
@test ùíØ == TriangleType[(2, 1, 9)]
add_triangle!(ùíØ, (2, 3, 10))
@test ùíØ == TriangleType[(2, 1, 9), (2, 3, 10)]
add_triangle!(ùíØ, (2, 3, 11), (11, 3, 4), (2, 3, 1))
@test ùíØ == TriangleType[(2, 1, 9), (2, 3, 10), (2, 3, 11), (11, 3, 4), (2, 3, 1)]
delete_triangle!(ùíØ, (2, 1, 9), (10, 2, 3))
@test ùíØ == TriangleType[(2, 3, 11), (11, 3, 4), (2, 3, 1)]

# Test that we can correctly remove adjacencies 
ùíún = TriAdjacent()
i, j, k, r = 1, 2, 3, 4
ùíún[(i, j)] = r
ùíún[(j, r)] = i
ùíún[(r, i)] = j
ùíún[(i, k)] = j
ùíún[(k, j)] = i
ùíún[(j, i)] = k
delete_edge_from_adjacency!(ùíún, i, j)
@test length(ùíún.adjacent) == 4
@test (i, j) ‚àâ keys(ùíún.adjacent)
@test (j, i) ‚àâ keys(ùíún.adjacent)
@test ùíún(j, r) == i
@test ùíún(r, i) == j
@test ùíún(i, k) == j
@test ùíún(k, j) == i

# Test that we can correctly flip an edge
I = [-2.0, -2.0]
J = [-10.0, 2.0]
K = [-4.0, 4.0]
R = [-8.0, -3.0]
IJKR = [I, J, K, R]
i, j, k, r = 1, 2, 3, 4
ùíün = TriDAG()
T·µ¢‚Çñ‚±º = TriangleType((i, k, j))
T·µ¢‚±º·µ£ = TriangleType((i, j, r))
ùíØn = TriangleType[T·µ¢‚Çñ‚±º, T·µ¢‚±º·µ£]
add!(ùíün, T·µ¢‚Çñ‚±º)
add!(ùíün, T·µ¢‚±º·µ£)
ùíún = TriAdjacent()
ùíún[(i, j)] = r
ùíún[(j, r)] = i
ùíún[(r, i)] = j
ùíún[(i, k)] = j
ùíún[(k, j)] = i
ùíún[(j, i)] = k
ùí±ùí©n = TriVertexNeighbours(Dict(
    i => [k, j, r],
    j => [r, i, k],
    k => [j, i],
    r => [i, j]
))
ùíØùíØ = deepcopy(ùíØn)
ùíüùíü = deepcopy(ùíün)
ùíúùíú = deepcopy(ùíún)
ùí±ùí± = deepcopy(ùí±ùí©n)
@test !is_legal(i, j, ùíún, IJKR)
flip_edge!(ùíØn, ùíün, ùíún, ùí±ùí©n, i, j, k, r)
@test is_legal(r, k, ùíún, IJKR)
T·µ£‚Çñ‚±º = TriangleType((r, k, j))
T·µ£·µ¢‚Çñ = TriangleType((r, i, k))
@test length(ùíún.adjacent) == 6
@test (i, j) ‚àâ keys(ùíún.adjacent)
@test (j, i) ‚àâ keys(ùíún.adjacent)
@test ùíØn == TriangleType[T·µ£‚Çñ‚±º, T·µ£·µ¢‚Çñ]
@test ùíún(j, r) == k
@test ùíún(r, k) == j
@test ùíún(k, j) == r
@test ùíún(r, i) == k
@test ùíún(i, k) == r
@test ùíún(k, r) == i
@test ùíün.graph.N[(i, k, j)] == Set(TriangleType[(r, k, j), (r, i, k)])
@test ùíün.graph.N[(i, j, r)] == Set(TriangleType[(r, k, j), (r, i, k)])
@test all(==(1), orient.(ùíØn, Ref(IJKR)))
@test ùí±ùí©n(i) == [k, r]
@test ùí±ùí©n(j) == [r, k]
@test ùí±ùí©n(r) == [i, j, k]
@test ùí±ùí©n(k) == [j, i, r]
flip_edge!(ùíØn, ùíün, ùíún, ùí±ùí©n, r, k, i, j) # This should go back to the original configuration
@test ùíØn == TriangleType[(2, 1, 3), (2, 4, 1)]
@test ùíúùíú.adjacent == ùíún.adjacent
@test all(sort(ùí±ùí±(i)) == sort(ùí±ùí©n(i)) for i in 1:4)
@test !is_legal(i, j, ùíún, IJKR)

p0 = Float64[5, 5]
p1 = Float64[4.5, 2.5]
p2 = Float64[2.5, 1.5]
p3 = Float64[3, 3.5]
p4 = Float64[0, 2]
p5 = Float64[1, 5]
p6 = Float64[1, 3]
p7 = Float64[4, -1]
p8 = Float64[-1, 4]
pts = [p0, p1, p2, p3, p4, p5, p6, p7, p8]

# Test triangle orientation
@test orient((4, 6, 7), pts) == 1
@test orient((4, 7, 6), pts) == -1
@test orient((4, 2, 3), pts) == -1
@test orient((4, 7, 3), pts) == 1
@test orient((5, 7, 9), pts) == 1
@test orient((5, 9, 7), pts) == -1
@test orient((3, 8, 5), pts) == -1
@test orient((1, 2, 3), [[1.0, 2.0], [1.0, 5.0], [1.0, 8.0]]) == 0

# Test that we can find points to the left of a line 
G = Float64[-8, -13]
H = Float64[-3, -10]
I = Float64[-4, -13]
J = Float64[-6, -9]
xg, yg = G
xh, yh = H
xi, yi = I
x, y = J
@test leftofline(x, y, xg, yg, xh, yh) == 1 # To the left of line from g to h 
@test leftofline(x, y, xh, yh, xi, yi) == -1 # To the right of line from h to i 
@test leftofline(x, y, xi, yi, xg, yg) == -1 # To the left of line from i to g
J = Float64[-5, -12]
x, y = J
@test leftofline(x, y, xg, yg, xh, yh) == -1 # Point is to the left of all halfplanes, so it is inside
@test leftofline(x, y, xh, yh, xi, yi) == -1 # Point is to the left of all halfplanes, so it is inside
@test leftofline(x, y, xi, yi, xg, yg) == -1 # Point is to the left of all halfplanes, so it is inside

# Test that we can decide whether a point is in a triangle, or on an edge
@test intriangle((2, 3, 4), pts, [3.5, 2.5]) == 1
@test intriangle(p6, p2, p3, [2.0, 3.0]) == 1
x1, y1, x2, y2, x3, y3 = 1 / 10, 1 / 9, 100 / 8, 100 / 3, 100 / 4, 100 / 9
x, y = x1 + (3 / 7) * (x2 - x1), y1 + (3 / 7) * (y2 - y1)
@test intriangle(x1, y1, x2, y2, x3, y3, x, y) == 1
x1, y1, x2, y2, x3, y3 = 2.0, -4.0, 4.0, -4.0, 3.0, -2.0
x, y = 3.0, -4.0
@test intriangle(x1, y1, x2, y2, x3, y3, x, y) == 0
y = y - 1e-12
@test intriangle(x1, y1, x2, y2, x3, y3, x, y) == -1
x, y = 2.5, -3.0
@test intriangle(x1, y1, x2, y2, x3, y3, x, y) == 0
x, y = 3.5, -3.0
@test intriangle(x1, y1, x2, y2, x3, y3, x, y) == 0
@test intriangle((6, 7, 4), pts, [6.0, 6.0]) == -1
@test intriangle((9, 5, 7), pts, [3.0, 3.0]) == -1
@test intriangle((9, 5, 7), pts, [0.0, 3.0]) == 1

## Now let's test what happens for the special points 
@test intriangle((1, 0, -1), pts, [0.0, 0.0]) == 1
p = [0.0, 6.0]
@test leftofline(pts, p, 1, -1) == 1
@test leftofline(pts, p, -1, 1) == -1
@test leftofline(pts, p, -1, 6) == -1
@test intriangle((0, 6, 1), pts, [3.0, 0.0]) == 1

## Test that we can add multiple triangles and edges to the DAG 
ùíü = TriDAG()
ùíüùíü = TriDAG()
T‚ÇÅ = TriangleType((1, 2, 3))
T‚ÇÇ = TriangleType((4, 5, 6))
T‚ÇÉ = TriangleType((7, 8, 9))
add_triangle!(ùíü, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ)
add!(ùíüùíü, T‚ÇÅ)
add!(ùíüùíü, T‚ÇÇ)
add!(ùíüùíü, T‚ÇÉ)
@test graph(ùíü) == graph(ùíüùíü)
add_triangle!(ùíü, TriangleType((2, 3, 1))) # same triangle as T‚ÇÅ
@test graph(ùíü) == graph(ùíüùíü)
add_triangle!(ùíü, TriangleType((2, 3, 1)), TriangleType((9, 7, 8))) # same as T‚ÇÅ and T‚ÇÉ
@test graph(ùíü) == graph(ùíüùíü)
add_edge!(ùíü, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ)
add!(ùíüùíü, T‚ÇÅ, T‚ÇÇ)
add!(ùíüùíü, T‚ÇÅ, T‚ÇÉ)
@test graph(ùíü) == graph(ùíüùíü)

# partialsort!(pts, 1, rev=true)
ùíØ = TriangleType[(LargeRightIdx + 1, LargeLeftIdx, LargeRightIdx)]
ùíü = TriDAG()
ùíú = TriAdjacent()
ùí±ùí© = TriVertexNeighbours()
add!(ùíü, ùíØ[begin])
root = ùíØ[begin]
@test collect(keys(graph(ùíü).V.dict))[1] == ùíØ[end]
ùíú[(LargeRightIdx + 1, LargeLeftIdx)] = LargeRightIdx
ùíú[(LargeLeftIdx, LargeRightIdx)] = LargeRightIdx + 1
ùíú[(LargeRightIdx, LargeRightIdx + 1)] = LargeLeftIdx
‚Ñ¨ = TriAdjacent()
update_adjacent!(‚Ñ¨, ùíØ[begin])
@test ùíú.adjacent == ‚Ñ¨.adjacent
ùíú[(LargeLeftIdx, LargeRightIdx + 1)] = EmptyIdx
ùíú[(LargeRightIdx, LargeLeftIdx)] = EmptyIdx
ùíú[(LargeRightIdx + 1, LargeRightIdx)] = EmptyIdx
add_neighbour!(ùí±ùí©, 1, -1, 0; new_point=true)
add_neighbour!(ùí±ùí©, -1, 0, 1; new_point=true)
add_neighbour!(ùí±ùí©, 0, 1, -1; new_point=true)
T, D, A, VN, _root = initialise_triangulation()
@test T == ùíØ
@test graph(ùíü) == graph(D)
@test ùíú.adjacent == A.adjacent
@test ùí±ùí©.neighbours == VN.neighbours
@test root == _root

# @views shuffle!(pts[begin+1:end])

r = 2
p·µ£ = pts[r]
T·µ¢‚±º‚Çñ, flag = locate_triangle(ùíü, pts, p·µ£, root)
_T·µ¢‚±º‚Çñ, _flag = locate_triangle(ùíü, pts, p·µ£)
@test T·µ¢‚±º‚Çñ == _T·µ¢‚±º‚Çñ
@test flag == _flag
# if flag == 1 # on interior 
# Now add the triangles. (i, j, k) becomes (i, j, r), (j, k, r), (k, i, r); these triangles are all positively oriented 
i, j, k = T·µ¢‚±º‚Çñ
ùíüùíü = deepcopy(ùíü)
ùíúùíú = deepcopy(ùíú)
ùíØùíØ = deepcopy(ùíØ)
ùí±ùí± = deepcopy(ùí±ùí©)
push!(ùíØ, TriangleType((i, j, r)), TriangleType((j, k, r)), TriangleType((k, i, r)))
deleteat!(ùíØ, 1)
add!(ùíü, TriangleType((i, j, r)))
add!(ùíü, TriangleType((j, k, r)))
add!(ùíü, TriangleType((k, i, r)))
add!(ùíü, TriangleType((i, j, k)), TriangleType((i, j, r)))
add!(ùíü, TriangleType((i, j, k)), TriangleType((j, k, r)))
add!(ùíü, TriangleType((i, j, k)), TriangleType((k, i, r)))
update_adjacent!(ùíú, TriangleType((i, j, r)))
update_adjacent!(ùíú, TriangleType((j, k, r)))
update_adjacent!(ùíú, TriangleType((k, i, r)))
add_neighbour!(ùí±ùí©, 1, 2)
add_neighbour!(ùí±ùí©, -1, 2)
add_neighbour!(ùí±ùí©, 0, 2)
add_neighbour!(ùí±ùí©, 2, 1, -1, 0)
add_point!(ùíØùíØ, ùíüùíü, ùíúùíú, ùí±ùí±, T·µ¢‚±º‚Çñ, r)
@test ùíØ == ùíØùíØ
@test ùíü.graph == ùíüùíü.graph
@test ùíú.adjacent == ùíúùíú.adjacent
@test ùí±ùí©.neighbours == ùí±ùí±.neighbours
@test collect(ùíü.graph.N[(1, -1, 0)]) == TriangleType[(1, -1, 2), (-1, 0, 2), (0, 1, 2)]
@test collect(ùíü.graph.NN[(1, -1, 2)]) == TriangleType[(1, -1, 0)]
@test collect(ùíü.graph.NN[(-1, 0, 2)]) == TriangleType[(1, -1, 0)]
@test collect(ùíü.graph.NN[(0, 1, 2)]) == TriangleType[(1, -1, 0)]
@test !ùíü.graph.looped
@test collect(ùíü.graph.V) == TriangleType[(1, -1, 0), (1, -1, 2), (-1, 0, 2), (0, 1, 2)]
a1, a2, a3 = ùíØ[1]
b1, b2, b3 = ùíØ[2]
c1, c2, c3 = ùíØ[3]
@test TriangleType((1, -1, 0)) ‚àâ ùíØ
@test (a1, a2, a3) == (1, -1, 2)
@test (b1, b2, b3) == (-1, 0, 2)
@test (c1, c2, c3) == (0, 1, 2)
@test ùíú(-1, 1) == EmptyIdx
@test ùíú(0, -1) == EmptyIdx
@test ùíú(1, 0) == EmptyIdx
@test ùíú(1, -1) == 2
@test ùíú(-1, 0) == 2
@test ùíú(0, 1) == 2
@test ùíú(-1, 2) == 1
@test ùíú(2, -1) == 0
@test ùíú(2, 1) == -1
@test ùíú(1, 2) == 0
@test ùíú(2, 0) == 1
@test ùíú(0, 2) == -1
@test length(ùíú.adjacent) == 12
@test ùí±ùí©(1) == [-1, 0, 2]
@test ùí±ùí©(-1) == [0, 1, 2]
@test ùí±ùí©(0) == [1, -1, 2]
@test ùí±ùí©(2) == [1, -1, 0]

# Make sure we can detect legal edges
@test edge_on_large_triangle(1, 0)
@test edge_on_large_triangle(0, 1)
@test edge_on_large_triangle(0, -1)
@test edge_on_large_triangle(-1, 0)
@test edge_on_large_triangle(-1, 1)
@test edge_on_large_triangle(1, -1)
@test !edge_on_large_triangle(1, 5)
@test !edge_on_large_triangle(0, 2)
@test !edge_on_large_triangle(-1, 2)
@test !edge_on_large_triangle(0, -2)
@test incircle(pts, 5, 7, 6, 9) == 1
@test incircle(pts, 5, 7, 6, 3) == -1
@test incircle(pts, 5, 7, 6, 3) == -1
@test incircle(pts, 5, 7, 6, 6) == 0
@test incircle(pts, 3, 2, 1, 4) == 1
@test incircle(pts, 3, 2, 1, 6) == 1
@test incircle(pts, 3, 2, 1, 7) == 1
@test incircle(pts, 3, 2, 1, 5) == -1
@test incircle(pts, 3, 2, 1, 8) == -1
@test is_legal(0, -1, ùíú, pts)
@test is_legal(1, -1, ùíú, pts)
@test is_legal(1, 0, ùíú, pts)
@test is_legal(-1, 0, ùíú, pts)
@test is_legal(-1, 1, ùíú, pts)
@test is_legal(0, 1, ùíú, pts)
@test !is_legal(7, 1, 6, 4, pts)
@test is_legal(7, 6, 9, 4, pts)
@test is_legal(7, 3, 4, 5, pts)
@test is_legal(7, 4, 6, 2, pts)
@test is_legal(k, i, ùíú, pts)
ùíúùíú = deepcopy(ùíú)
ùíüùíü = deepcopy(ùíü)
ùíØùíØ = deepcopy(ùíØ)
ùí±ùí± = deepcopy(ùí±ùí©)
legalise_edge!(ùíØùíØ, ùíüùíü, ùíúùíú, ùí±ùí±, i, j, r, pts)
legalise_edge!(ùíØùíØ, ùíüùíü, ùíúùíú, ùí±ùí±, j, k, r, pts)
legalise_edge!(ùíØùíØ, ùíüùíü, ùíúùíú, ùí±ùí±, k, i, r, pts)
@test ùíØ == ùíØùíØ
@test ùíü.graph == ùíüùíü.graph
@test ùíú.adjacent == ùíúùíú.adjacent
@test ùí±ùí©.neighbours == ùí±ùí±.neighbours

## Add the next point 
r = 3
p·µ£ = pts[r]
T·µ¢‚±º‚Çñ, flag = locate_triangle(ùíü, pts, p·µ£, root)
_T·µ¢‚±º‚Çñ, _flag = locate_triangle(ùíü, pts, p·µ£)
@test T·µ¢‚±º‚Çñ == _T·µ¢‚±º‚Çñ
@test flag == _flag
@test flag == 1
@test T·µ¢‚±º‚Çñ == TriangleType((LargeLeftIdx, LargeRightIdx, 2))
add_point!(ùíØ, ùíü, ùíú, ùí±ùí©, T·µ¢‚±º‚Çñ, r)
@test length(ùíú.adjacent) == 18
@test ùíú(-1, 1) == EmptyIdx
@test ùíú(1, -1) == 2
@test ùíú(-1, 0) == 3
@test ùíú(0, -1) == EmptyIdx
@test ùíú(0, 1) == 2
@test ùíú(1, 0) == EmptyIdx
@test ùíú(-1, 2) == 1
@test ùíú(2, -1) == 3
@test ùíú(2, 1) == -1
@test ùíú(1, 2) == 0
@test ùíú(2, 0) == 1
@test ùíú(0, 2) == 3
@test ùíú(2, 3) == 0
@test ùíú(3, 2) == -1
@test ùíú(3, -1) == 0
@test ùíú(-1, 3) == 2
@test ùíú(3, 0) == 2
@test ùíú(0, 3) == -1
@test collect(ùíü.graph.N[(1, -1, 0)]) == TriangleType[(1, -1, 2), (-1, 0, 2), (0, 1, 2)]
@test collect(ùíü.graph.N[(-1, 0, 2)]) == TriangleType[(-1, 0, 3), (0, 2, 3), (2, -1, 3)]
@test collect(ùíü.graph.NN[(1, -1, 0)]) == []
@test collect(ùíü.graph.NN[(1, -1, 2)]) == TriangleType[(1, -1, 0)]
@test collect(ùíü.graph.NN[(-1, 0, 2)]) == TriangleType[(1, -1, 0)]
@test collect(ùíü.graph.NN[(-1, 0, 3)]) == TriangleType[(-1, 0, 2)]
@test collect(ùíü.graph.NN[(0, 1, 2)]) == TriangleType[(1, -1, 0)]
@test collect(ùíü.graph.NN[(0, 2, 3)]) == TriangleType[(-1, 0, 2)]
@test collect(ùíü.graph.NN[(2, -1, 3)]) == TriangleType[(-1, 0, 2)]
i, j, k = T·µ¢‚±º‚Çñ
@test is_legal(i, j, ùíú, pts)
ùíúùíú = deepcopy(ùíú)
ùíüùíü = deepcopy(ùíü)
ùíØùíØ = deepcopy(ùíØ)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, r, pts)
@test ùíØ == ùíØùíØ
@test ùíü.graph == ùíüùíü.graph
@test ùíú.adjacent == ùíúùíú.adjacent
@test !is_legal(j, k, ùíú, pts)
@test ùíú(1, 2) == LargeRightIdx
@test ùíú(2, 1) == LargeLeftIdx
@test ùíú(2, 3) == LargeRightIdx
@test ùíú(3, 2) == LargeLeftIdx
@test ùíú(LargeLeftIdx, 3) == 2
@test ùíú(1, LargeLeftIdx) == 2
@test ùí±ùí©(0) == [1, -1, 2, 3]
@test ùí±ùí©(1) == [-1, 0, 2]
@test ùí±ùí©(2) == [1, -1, 0, 3]
@test ùí±ùí©(3) == [-1, 0, 2]

# Test that we can correctly legalise the edges 
@test is_legal(i, j, ùíú, pts)
ùíüùíü = deepcopy(ùíü)
ùíúùíú = deepcopy(ùíú)
ùíØùíØ = deepcopy(ùíØ)
ùí±ùí± = deepcopy(ùí±ùí©)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, r, pts)
@test ùíüùíü.graph == ùíü.graph
@test ùíúùíú.adjacent == ùíú.adjacent
@test ùíØùíØ == ùíØ
@test ùí±ùí±.neighbours == ùí±ùí©.neighbours
@test !is_legal(j, k, ùíú, pts)
_i = ùíú(k, j)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, j, k, r, pts)
@test ùíüùíü.graph ‚â† ùíü.graph
@test ùíúùíú.adjacent ‚â† ùíú.adjacent
@test ùíØùíØ ‚â† ùíØ
@test ùí±ùí©.neighbours ‚â† ùí±ùí±.neighbours
@test is_legal(_i, r, ùíú, pts)

## Now let's do a clearer run through
p0 = Float64[5, 5]
p1 = Float64[4.5, 2.5]
p2 = Float64[2.5, 1.5]
p3 = Float64[3, 3.5]
p4 = Float64[0, 2]
p5 = Float64[1, 5]
p6 = Float64[1, 3]
p7 = Float64[4, -1]
p8 = Float64[-1, 4]
pts = [p0, p1, p2, p3, p4, p5, p6, p7, p8]

# Initialise 
ùíØ, ùíü, ùíú, ùí±ùí©, root = initialise_triangulation()

# Add the second point 
r = 2
p·µ£ = pts[r]
ùíØ·µ¢‚±º‚Çñ, interior_flag = locate_triangle(ùíü, pts, p·µ£, root)
i, j, k = ùíØ·µ¢‚±º‚Çñ
add_point!(ùíØ, ùíü, ùíú, ùí±ùí©, ùíØ·µ¢‚±º‚Çñ, r)
@test is_legal(i, j, ùíú, pts)
@test is_legal(j, k, ùíú, pts)
@test is_legal(k, i, ùíú, pts)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, r, pts)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, j, k, r, pts)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, k, i, r, pts)
@test ùíØ == TriangleType[(1, -1, 2), (-1, 0, 2), (0, 1, 2)]

# Add the third point 
r = 3
p·µ£ = pts[r]
ùíØ·µ¢‚±º‚Çñ, interior_flag = locate_triangle(ùíü, pts, p·µ£, root)
i, j, k = ùíØ·µ¢‚±º‚Çñ
add_point!(ùíØ, ùíü, ùíú, ùí±ùí©, ùíØ·µ¢‚±º‚Çñ, r)
@test ùíØ == TriangleType[(1, -1, 2), (0, 1, 2), (-1, 0, 3), (0, 2, 3), (2, -1, 3)]
@test ùíú(1, -1) == 2
@test ùíú(-1, 2) == 1
@test ùíú(2, 1) == -1
@test ùíú(0, 1) == 2
@test ùíú(1, 2) == 0
@test ùíú(2, 0) == 1
@test ùíú(-1, 0) == 3
@test ùíú(0, 3) == -1
@test ùíú(3, -1) == 0
@test ùíú(0, 2) == 3
@test ùíú(2, 3) == 0
@test ùíú(3, 0) == 2
@test ùíú(2, -1) == 3
@test ùíú(-1, 3) == 2
@test ùíú(3, 2) == -1
@test sort(ùí±ùí©(-1)) == [0, 1, 2, 3]
@test sort(ùí±ùí©(0)) == [-1, 1, 2, 3]
@test sort(ùí±ùí©(1)) == [-1, 0, 2]
@test sort(ùí±ùí©(2)) == [-1, 0, 1, 3]
@test sort(ùí±ùí©(3)) == [-1, 0, 2]
@test is_legal(i, j, ùíú, pts)
legalise_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, i, j, r, pts)
@test ùíØ == TriangleType[(1, -1, 2), (0, 1, 2), (-1, 0, 3), (0, 2, 3), (2, -1, 3)]
@test !is_legal(j, k, ùíú, pts)
@test ùíú(j, k) == r
@test ùíú(k, j) == 1
_i, _j, _k = j, k, 1
flip_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, _i, _j, _k, r)
@test ùíØ == TriangleType[(1, -1, 2), (-1, 0, 3), (2, -1, 3), (3, 1, 2), (3, 0, 1)]
@test is_legal(_i, _k, ùíú, pts)
@test is_legal(_k, _j, ùíú, pts)
@test is_legal(j, 1, ùíú, pts)
@test is_legal(1, k, ùíú, pts)
@test ùíú(1, -1) == 2
@test ùíú(-1, 2) == 1
@test ùíú(2, 1) == -1
@test ùíú(-1, 0) == 3
@test ùíú(0, 3) == -1
@test ùíú(3, -1) == 0
@test ùíú(2, -1) == 3
@test ùíú(-1, 3) == 2
@test ùíú(3, 2) == -1
@test ùíú(3, 1) == 2
@test ùíú(1, 2) == 3
@test ùíú(2, 3) == 1
@test ùíú(3, 0) == 1
@test ùíú(0, 1) == 3
@test ùíú(1, 3) == 0

# Add the fourth point 
r = 4
p·µ£ = pts[r]
ùíØ·µ¢‚±º‚Çñ, interior_flag = locate_triangle(ùíü, pts, p·µ£, root)
@test ùíØ·µ¢‚±º‚Çñ == TriangleType((2, -1, 3))
@test interior_flag == 1
i, j, k = ùíØ·µ¢‚±º‚Çñ
add_point!(ùíØ, ùíü, ùíú, ùí±ùí©, ùíØ·µ¢‚±º‚Çñ, r)
@test ùíØ == TriangleType[(1, -1, 2), (-1, 0, 3), (3, 1, 2), (3, 0, 1), (2, -1, 4), (-1, 3, 4), (3, 2, 4)]
@test ùíú(1, -1) == 2
@test ùíú(-1, 2) == 1
@test ùíú(2, 1) == -1
@test ùíú(-1, 0) == 3
@test ùíú(0, 3) == -1
@test ùíú(3, -1) == 0
@test ùíú(3, 1) == 2
@test ùíú(1, 2) == 3
@test ùíú(2, 3) == 1
@test ùíú(3, 0) == 1
@test ùíú(0, 1) == 3
@test ùíú(1, 3) == 0
@test ùíú(2, -1) == 4
@test ùíú(-1, 4) == 2
@test ùíú(4, 2) == -1
@test ùíú(-1, 3) == 4
@test ùíú(3, 4) == -1
@test ùíú(4, -1) == 3
@test ùíú(3, 2) == 4
@test ùíú(2, 4) == 3
@test ùíú(4, 3) == 2
@test ùíú(-1, 1) == EmptyIdx
@test ùíú(0, -1) == EmptyIdx
@test ùíú(1, 0) == EmptyIdx
@test !is_legal(i, j, ùíú, pts)
@test ùíú(j, i) == 1
_i, _j, _k = i, j, 1
flip_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, _i, _j, _k, r)
@test ùíØ == TriangleType[(-1, 0, 3), (3, 1, 2), (3, 0, 1), (-1, 3, 4), (3, 2, 4), (4, 1, -1), (4, 2, 1)]
@test ùíú(1, -1) == 4
@test (-1, 2) ‚àâ keys(ùíú.adjacent)
@test ùíú(-1, 0) == 3
@test ùíú(0, 3) == -1
@test ùíú(3, -1) == 0
@test ùíú(3, 1) == 2
@test ùíú(2, 3) == 1
@test ùíú(3, 0) == 1
@test ùíú(0, 1) == 3
@test ùíú(1, 3) == 0
@test (2, -1) ‚àâ keys(ùíú.adjacent)
@test ùíú(-1, 4) == 1
@test ùíú(4, 2) == 1
@test ùíú(-1, 3) == 4
@test ùíú(3, 4) == -1
@test ùíú(4, -1) == 3
@test ùíú(3, 2) == 4
@test ùíú(2, 4) == 3
@test ùíú(4, 3) == 2
@test ùíú(-1, 1) == EmptyIdx
@test ùíú(0, -1) == EmptyIdx
@test ùíú(1, 0) == EmptyIdx
@test ùíú(4, 1) == -1
@test ùíú(1, 4) == 2
@test (3, 1) ‚àà keys(ùíú.adjacent)
@test is_legal(_i, _k, ùíú, pts)
@test is_legal(_k, _j, ùíú, pts)
@test is_legal(4, 1, ùíú, pts)
@test !is_legal(j, k, ùíú, pts)
_i, _j, _k = j, k, 0
flip_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, _i, _j, _k, r)
@test ùíØ == TriangleType[(3, 1, 2), (3, 0, 1), (3, 2, 4), (4, 1, -1), (4, 2, 1), (4, 0, 3), (4, -1, 0)]
@test ùíú(3, 1) == 2
@test ùíú(1, 2) == 3
@test ùíú(2, 3) == 1
@test ùíú(3, 0) == 1
@test ùíú(0, 1) == 3
@test ùíú(1, 3) == 0
@test ùíú(3, 2) == 4
@test ùíú(2, 4) == 3
@test ùíú(4, 3) == 2
@test ùíú(4, 1) == -1
@test ùíú(1, -1) == 4
@test ùíú(-1, 4) == 1
@test ùíú(4, 2) == 1
@test ùíú(2, 1) == 4
@test ùíú(1, 4) == 2
@test ùíú(4, 0) == 3
@test ùíú(0, 3) == 4
@test ùíú(3, 4) == 0
@test ùíú(4, -1) == 0
@test ùíú(-1, 0) == 4
@test ùíú(0, 4) == -1
@test (3, 1) ‚àà keys(ùíú.adjacent)
@test is_legal(_i, _k, ùíú, pts)
@test !is_legal(_k, _j, ùíú, pts)
_i, _j = _k, _j
_k = ùíú(_j, _i)
flip_edge!(ùíØ, ùíü, ùíú, ùí±ùí©, _i, _j, _k, r)
@test ùíØ == TriangleType[(3, 1, 2), (3, 2, 4), (4, 1, -1), (4, 2, 1), (4, -1, 0), (4, 1, 3), (4, 0, 1)]
@test ùíú(-1, 1) == EmptyIdx
@test ùíú(0, -1) == EmptyIdx
@test ùíú(1, 0) == EmptyIdx
@test ùíú(3, 1) == 2
@test ùíú(1, 2) == 3
@test ùíú(2, 3) == 1
@test ùíú(3, 2) == 4
@test ùíú(2, 4) == 3
@test ùíú(4, 3) == 2
@test ùíú(4, 1) == 3
@test ùíú(1, -1) == 4
@test ùíú(-1, 4) == 1
@test ùíú(4, 2) == 1
@test ùíú(2, 1) == 4
@test ùíú(1, 4) == 0
@test ùíú(4, -1) == 0
@test ùíú(-1, 0) == 4
@test ùíú(0, 4) == -1
@test ùíú(4, 1) == 3
@test ùíú(1, 3) == 4
@test ùíú(3, 4) == 1
@test ùíú(4, 0) == 1
@test ùíú(0, 1) == 4
@test ùíú(1, 4) == 0
@test is_legal(4, 0, ùíú, pts)
@test is_legal(k, i, ùíú, pts)

## Do a smaller example 
p1 = Float64[20, 20]
p2 = Float64[0, 6]
p3 = Float64[12, -2]
p4 = Float64[10, 10]
PTS = [p1, p2, p3, p4]
ùíØ, ùíü, ùíú, ùí±ùí© = triangulate(PTS; shuffle_pts=false, trim=false)
@test ùíØ == TriangleType[
    (1, -1, 2),
    (-1, 0, 2),
    (0, 1, 3),
    (2, 0, 3),
    (1, 2, 4),
    (2, 3, 4),
    (3, 1, 4)
]
@test ùíú(1, -1) == 2
@test ùíú(-1, 2) == 1
@test ùíú(2, 1) == -1
@test ùíú(-1, 0) == 2
@test ùíú(0, 2) == -1
@test ùíú(2, -1) == 0
@test ùíú(0, 1) == 3
@test ùíú(1, 3) == 0
@test ùíú(3, 0) == 1
@test ùíú(2, 0) == 3
@test ùíú(0, 3) == 2
@test ùíú(3, 2) == 0
@test ùíú(1, 2) == 4
@test ùíú(2, 4) == 1
@test ùíú(4, 1) == 2
@test ùíú(2, 3) == 4
@test ùíú(3, 4) == 2
@test ùíú(4, 2) == 3
@test ùíú(3, 1) == 4
@test ùíú(1, 4) == 3
@test ùíú(4, 3) == 1
@test sort(ùí±ùí©(-1)) == [0, 1, 2]
@test sort(ùí±ùí©(0)) == [-1, 1, 2, 3]
@test sort(ùí±ùí©(1)) == [-1, 0, 2, 3, 4]
@test sort(ùí±ùí©(2)) == [-1, 0, 1, 3, 4]
@test sort(ùí±ùí©(3)) == [0, 1, 2, 4]
@test sort(ùí±ùí©(4)) == [1, 2, 3]

w‚ÇÅ = ùíú(1, -1)
delete_triangle!(ùíØ, TriangleType((1, -1, w‚ÇÅ)))
delete_edge_from_adjacency!(ùíú, 1, -1; protect_boundary=false)
delete_edge_from_adjacency!(ùíú, -1, w; protect_boundary=false)
ùíú[(w‚ÇÅ, 1)] = EmptyIdx

w‚ÇÇ = ùíú(-1, 0)
delete_triangle!(ùíØ, TriangleType((-1, 0, w‚ÇÇ)))
delete_edge_from_adjacency!(ùíú, -1, 0; protect_boundary=false)
delete_edge_from_adjacency!(ùíú, 0, w‚ÇÇ; protect_boundary=false)

w‚ÇÉ = ùíú(0, 1)
delete_triangle!(ùíØ, TriangleType((0, 1, w‚ÇÉ)))
delete_edge_from_adjacency!(ùíú, 0, 1; protect_boundary=false)
delete_edge_from_adjacency!(ùíú, 0, w‚ÇÉ; protect_boundary=false)
ùíú[(w‚ÇÉ, w‚ÇÇ)] = EmptyIdx
ùíú[(1, w‚ÇÉ)] = EmptyIdx
ùíØ
@test ùíØ == [(2,)]